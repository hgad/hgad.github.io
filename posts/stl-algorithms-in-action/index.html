<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js"> <!--<![endif]-->
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>STL Algorithms in Action</title>
    <meta name="description" content="Demonstrating the versatility of STL algorithms by implementing famous sorting algorithms in terms of STL algorithms.">
    <meta name="viewport" content="width=device-width">

    <!-- Place favicon.ico and apple-touch-icon.png in the root directory -->
    <link rel="shortcut icon" type="image/png" href="../../img/favicon.png">
    <link rel="stylesheet" type="text/css" href="../../css/normalize.css">
    <link rel="stylesheet" type="text/css" media="screen and (min-device-width: 1025px)" href="../../css/style.css">
    <link rel="stylesheet" type="text/css" media="screen and (max-device-width: 1024px)" href="../../css/mobile.css">
    <link rel="stylesheet" type="text/css" href="../../css/font-awesome.min.css">

    <script src="../../js/vendor/modernizr-2.6.2.min.js"></script>

    <script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>
  </head>
  <body>
    <!--[if lt IE 7]>
      <p class="browsehappy">
        You are using an <strong>outdated</strong> browser. Please
        <a href="http://browsehappy.com/">upgrade your browser</a>
        to improve your experience.
      </p>
    <![endif]-->

    <!-- Add your site or application content here -->
    <header>
      <nav>
        <a href="../../">
          <img id="lambda" src="../../img/lambda.png" width="150" height="100">
        </a>

        <hr>

        <table>
          <tr>
            <td> <a href="../../">HOME</a> </td>
          </tr>
          <tr>
            <td> <a href="../../blog/1">BLOG</a> </td>
          </tr>
          <!--
          <tr>
            <td> <a href="/projects">PROJECTS</a> </td>
          </tr>
          -->
          <tr>
            <td> <a href="../../archive">ARCHIVE</a> </td>
          </tr>
          <tr>
            <td> <a href="../../about">ABOUT</a> </td>
          </tr>
        </table>
      </nav>
    </header>

    <!--
    <div class="gcse-searchbar">
      <script>
        (function() {
          var cx = '013374158812828085901:lnaifgecssc';
          var gcse = document.createElement('script');
          gcse.type = 'text/javascript';
          gcse.async = true;
          gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
              '//www.google.com/cse/cse.js?cx=' + cx;
          var s = document.getElementsByTagName('script')[0];
          s.parentNode.insertBefore(gcse, s);
        })();
      </script>
      <gcse:search></gcse:search>
    </div>
    -->

    <article>
      <header class="post-header">
  
    <h1>STL Algorithms in Action</h1>
  

  <p class="post-info">
    March 25, 2016
  </p>
</header>

<section class="post-body">
  <p>
  <p>Under tight schedules and looming deadlines, C++ programmers tend to ignore the Standard Library algorithms and settle for rather suboptimal handcrafted solutions that get the job done. I know this, because I myself have done it more than I’d care to admit. The excuse is usually that the problem does not fit any of these neat, but somewhat detached, algorithms.</p>
<p>STL algorithms are actually very handy. They give names to commonly occurring (and often cryptic) raw loops<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Until recently, however, they required too much work to use effectively. Thankfully, with the introduction of type inference and lambda expressions in C++11, STL algorithms are now a lot easier to use.</p>
<p>In this post, I’ll be demonstrating the versatility of STL algorithms by implementing common sorting algorithms (insertion sort, in-place merge sort and randomized quicksort) using STL algorithms as building blocks<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>. Sorting is the kind of problem that requires moving data around, and when implemented using raw loops, they tend to be unreadable. We’ll see how STL algorithms can describe this code more succinctly and possibly more efficiently.</p>
<h3 id="insertion-sort">Insertion Sort</h3>
<p>This is a C++ adaptation of insertion sort as it appears in CLRS<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
<span class="dt">void</span> insertion_sort(I first, I last) {
  <span class="kw">for</span> (<span class="kw">auto</span>&amp;&amp; j = next(first); j != last; ++j) {
    <span class="kw">auto</span> key = *j;
    <span class="kw">auto</span>&amp;&amp; i = prev(j);
    <span class="kw">while</span> (i != prev(first) &amp;&amp; *i &gt; key) {
      *next(i) = *i;
      --i;
    }

    *next(i) = key;
  }
}</code></pre></div>
<p>It’s compact and generic, but aside from the function name, it’s completely unobvious what the nested loops are doing at first sight. Let’s see how to make this more readable.</p>
<p>By examining the inner loop, it looks like it searches backwards in the given range for a value less than or equal to <code>key</code>. It starts from the value just before <code>j</code> down to <code>0</code>. In doing so, it also shifts all the values it scans one position to the right. Once the value is found (or we reach the beginning of the range), the value at <code>j</code> is then inserted.</p>
<p>Let’s pretend for a moment that the range is being scanned in the forward rather than the backward direction. In this case, all we need is a function that searches a range for an element (call it <code>k</code>) that satisfies a certain predicate. When <code>k</code> is found (or we reach the end of the range), the function has to insert the first element of the range before <code>k</code> and shift all elements between them one position to the left:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I, <span class="kw">typename</span> P&gt;
<span class="dt">void</span> insert_first_before(I first, I last, P pred) {
  <span class="kw">auto</span>&amp;&amp; second = next(first);
  rotate(first, second, find_if(second, last, pred));
}</code></pre></div>
<p>If you’re surprised to see <code>rotate()</code> being used here, you’re not alone. Sean Parent’s GoingNative 2013 <a href="https://www.youtube.com/watch?v=qH6sSOr-yk8">talk</a> was an eye-opener for me in this respect. Turns out <code>rotate()</code> is one of the handiest algorithms in the Standard Library. It takes three iterators: <code>first</code>, <code>middle</code> and <code>last</code>. It performs a left-rotate operation such that the elements between <code>middle</code> and <code>last</code> are moved to the beginning of the range, and the elements between <code>first</code> and <code>middle</code> are moved to the end of the range. It also returns an iterator to the beginning of the second range after rotation, which often comes in handy<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>. Essentially, every time you find yourself manually shifting elements, there’s almost always a better way to achieve the same effect using <code>rotate()</code><a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<p>Going back to our problem, what we originally needed was an algorithm that scans a range backwards not forwards. This can be achieved easily using <code>reverse_iterator</code>s:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I, <span class="kw">typename</span> P&gt;
<span class="dt">void</span> insert_last_after(I first, I last, P pred) {
  insert_first_before(
    make_reverse_iterator(last),
    make_reverse_iterator(first), pred);
}</code></pre></div>
<p>You may notice that the function name isn’t ideal. The word <code>last</code> in the function name refers to the last element in the range, while <code>last</code> the formal parameter, refers to the element one past the end of the range.</p>
<p>In any case, given <code>insert_last_after()</code>, <code>insertion_sort()</code> becomes trivial:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
<span class="dt">void</span> insertion_sort(I first, I last) {
  <span class="kw">for</span> (<span class="kw">auto</span>&amp;&amp; iter = next(first); iter != last; ++iter) {
    insert_last_after(first, next(iter),
      [iter] (<span class="kw">auto</span>&amp;&amp; value) { <span class="kw">return</span> value &lt;= *iter; });
  }
}</code></pre></div>
<p>Notice that the arguments to <code>insert_last_after()</code> are initialized with iterators one position to the right of where the <code>reverse_iterator</code>s are supposed to point. This is because <code>reverse_iterator</code>s refer to the position right before the one they’re initialized with.</p>
<p>But do we really need a linear search? If we notice the loop invariant that the range from <code>first</code> to <code>j</code> is always sorted, we can simply perform a binary search instead, which gives us an <em>O(n log n)</em> version of insertion sort. This can be achieved directly using <code>upper_bound()</code>. Once that element is found, we need to perform a right rotate to insert the element at <code>iter</code> before it. A right rotate can be implemented using <code>rotate()</code> with <code>reverse_iterator</code>s:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
I rotate_right(I first, I middle, I last) {
  <span class="kw">return</span> rotate(
           make_reverse_iterator(last),
           make_reverse_iterator(middle),
           make_reverse_iterator(first)).base();
}</code></pre></div>
<p><code>rotate()</code> returns an iterator of the same type as its arguments, which in this case are <code>reverse_iterator</code>s. For consistency’s sake, <code>rotate_right()</code> should behave similarly by returning an iterator of the same type as its arugments. That’s the reason I’m calling <code>base()</code> on <code>rotate()</code>’s return iterator to extract its <em>base iterator</em> (i.e. the forward iterator its wrapping).</p>
<p>The <em>O(n log n)</em> <code>insertion_sort()</code> follows directly:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
<span class="dt">void</span> insertion_sort(I first, I last) {
  <span class="kw">for</span> (<span class="kw">auto</span>&amp;&amp; iter = next(first); iter != last; ++iter) {
    rotate_right(upper_bound(first, iter, *iter),
                 iter, next(iter));
  }
}</code></pre></div>
<p><code>upper_bound()</code> returns the first element in a range that compares greater than a look-up key (or <code>last</code> if no such element exists). It does that in <em>O(log n)</em> time by requiring the range to be sorted or at least partitioned around the look-up key.</p>
<h3 id="in-place-merge-sort">In-Place Merge Sort</h3>
<p>The canonical implementation of merge sort partitions the given range in half and recursively sorts each half, but it performs the merge step in a separate range from that of the two partitions. In-place merge sort, on the other hand, performs the merge step in-place. The two partitions are kept adjacent in memory constituting one big range. The two elements at the beginning of each partition are compared and the smallest is moved to the beginning of the combined range shifting elements as necessary.</p>
<p>Following is the top-level <code>mergesort()</code> procedure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
<span class="dt">void</span> mergesort(I first, I last) {
  <span class="kw">auto</span>&amp;&amp; size = distance(first, last);
  <span class="kw">if</span> (size &lt; <span class="dv">2</span>) {
    <span class="kw">return</span>;
  }

  <span class="kw">auto</span>&amp;&amp; mid = first + size / <span class="dv">2</span> + size % <span class="dv">2</span>;

  mergesort(first, mid);
  mergesort(mid, last);
  merge(first, mid, last);
}</code></pre></div>
<p>As described, unless the given range has only one element, <code>mergesort()</code> partitions the given range in half and recursively sorts each half. Finally, it calls the in-place <code>merge()</code> procedure to merge the two sorted partitions. The two partitions are adjacent in memory with iterator <code>mid</code> pointing at the beginning of the second partition.</p>
<p>Here’s one way to implement the in-place <code>merge()</code> procedure:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">template</span> &lt;<span class="kw">typename</span> I&gt;
<span class="dt">void</span> merge(I first, I mid, I last) {
  <span class="kw">while</span> (first != mid &amp;&amp; mid != last) {
    <span class="kw">auto</span> iter = mid;
    first = upper_bound(first, mid, *mid);
    mid = upper_bound(mid, last, *first);
    rotate(first, iter, mid);
  }
}</code></pre></div>
<p>In every iteration, <code>merge()</code> does the following:</p>
<ol style="list-style-type: decimal">
<li><p>It skips over the first few elements in the first partition that are less than the first element of the second partition (i.e. <code>*mid</code>). These elements are essentially in their correct final location, so no need to move them. It does that by calling <code>upper_bound()</code> on the first partition and assigning the result back to <code>first</code>.</p></li>
<li><p>Next, it does the same thing for the second partition. It skips over the first few elements in the second partition that are greater than the value pointed at by <code>first</code>. This time it does it because these elements are all going to have to be moved before <code>first</code>, so there’s no point in moving them one-by-one if they can be moved as a batch.</p></li>
<li><p>Finally, it calls <code>rotate()</code> to move those elements before <code>first</code>.</p></li>
</ol>
<p>The loop stops when either of the two moving partitions is totally consumed. Neat, isn’t it?!</p>
<h3 id="randomized-quicksort">Randomized Quicksort</h3>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>``One thing every sorcerer will tell you is if you have the name of a spirit, you have power over it.’’ —Gerald Jay Sussman<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>Obviously I won’t be using <code>std::sort()</code>!<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>Introduction to Algorithms, by Cormen et al.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>Before C++11, <code>rotate()</code> used to return <code>void</code>.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p><code>rotate()</code> can be implemented in <em>O(n)</em> time using three <code>reverse()</code>s. In fact, this implementation results in a number of swaps almost exactly equals to <em>n</em>.<a href="#fnref5">↩</a></p></li>
</ol>
</div>
  </p>

  <p class="tag-list">
  <strong>Tags:</strong> <a href="../../tags/C%2B%2B/">C++</a>, <a href="../../tags/STL/">STL</a>, <a href="../../tags/Algorithms/">Algorithms</a>.
  <p></p>
</section>


<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'haithamgad'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>



      <aside id="fractal">
        <img src="../../img/fractal.png" width="150" height="80">
      </aside>

      <!--[if gt IE 7]><!-->
      <aside id="socialbar">
        <section>
          <a href="http://google.com/+HaithamGad" target="_blank" title="Google+">
            <i class="fa fa-google-plus-box"></i></a>
          <a href="https://twitter.com/hgad" target="_blank" title="Twitter">
            <i class="fa fa-twitter-box"></i></a>
          <a href="http://www.linkedin.com/in/haithamgad" target="_blank" title="LinkedIn"><i class="fa fa-linkedin-box"></i></a>
          <a href="https://github.com/hgad" target="_blank" title="GitHub">
            <i class="fa fa-github-box"></i></a>
          <a href="../../feed.xml" title="Feed">
            <i class="fa fa-rss-box"></i></a>
        </section>
      </aside>
      <!--<![endif]-->
    </article>

    <footer>
      <table>
        <tr>
          <td id="license">
            &copy; 2016 Haitham Gad
          </td>
          <td id="hakyll">
            Generated by
            <a target="_blank" href="http://jaspervdj.be/hakyll">Hakyll</a>
          </td>
        </tr>
      </table>
    </footer>

    <script src="../../js/vendor/jquery-1.10.2.min.js">
    </script>

    <script src="../../js/plugins.js"></script>
    <script src="../../js/main.js"></script>

    <!-- Google Analytics: change UA-XXXXX-X to be your site's ID. -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-45318006-1', 'hgad.net');
      ga('send', 'pageview');

    </script>
  </body>
</html>

